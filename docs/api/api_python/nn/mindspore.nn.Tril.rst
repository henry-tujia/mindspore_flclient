mindspore.nn.Tril
=================

.. py:class:: mindspore.nn.Tril

    返回一个Tensor，其中第 `k` 个对角线以上的元素被置为零。

    矩阵的下三角把矩阵分成对角线上和对角线下的元素。

    参数 `k` 控制着矩阵的对角线。如果 `k` 为0，则保留主对角线上和下面的所有元素。正值包括主对角线上方尽可能多的对角线，类似地，负值排除主对角线下方尽可能多的对角线。

    **输入：**

    - **x** (Tensor)：输入Tensor。数据类型为Number。shape为 :math:`(N,*)`，其中 :math:`*` 表示任意的附加维度数。
    - **k** (Int)：对角线的索引。默认值：0。

    **输出：**

    Tensor，shape和数据类型与 `x` 相同。

    **异常：**

    - **TypeError：** `k` 不是int。
    - **ValueError：** `x` 的维度小于1。

    **支持平台：**

    ``Ascend`` ``GPU`` ``CPU``

    **样例：**

    >>> x = Tensor(np.array([[ 1,  2,  3,  4],
    ...                      [ 5,  6,  7,  8],
    ...                      [10, 11, 12, 13],
    ...                      [14, 15, 16, 17]]))
    >>> tril = nn.Tril()
    >>> result = tril(x)
    >>> print(result)
    [[ 1  0  0  0]
     [ 5  6  0  0]
     [10 11 12  0]
     [14 15 16 17]]
    >>> x = Tensor(np.array([[ 1,  2,  3,  4],
    ...                      [ 5,  6,  7,  8],
    ...                      [10, 11, 12, 13],
    ...                      [14, 15, 16, 17]]))
    >>> tril = nn.Tril()
    >>> result = tril(x, 1)
    >>> print(result)
    [[ 1  2  0  0]
     [ 5  6  7  0]
     [10 11 12 13]
     [14 15 16 17]]
    >>> x = Tensor(np.array([[ 1,  2,  3,  4],
    ...                      [ 5,  6,  7,  8],
    ...                      [10, 11, 12, 13],
    ...                      [14, 15, 16, 17]]))
    >>> tril = nn.Tril()
    >>> result = tril(x, 2)
    >>> print(result)
    [[ 1  2  3  0]
     [ 5  6  7  8]
     [10 11 12 13]
     [14 15 16 17]]
    >>> x = Tensor(np.array([[ 1,  2,  3,  4],
    ...                      [ 5,  6,  7,  8],
    ...                      [10, 11, 12, 13],
    ...                      [14, 15, 16, 17]]))
    >>> tril = nn.Tril()
    >>> result = tril(x, -1)
    >>> print(result)
    [[ 0  0  0  0]
     [ 5  0  0  0]
     [10 11  0  0]
     [14 15 16  0]]
